{% extends "admin/base_site.html" %}
{% load static %}

{% block extrastyle %}
  {{ block.super }}
  <style>
    .ai-blog-editor-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 20px;
    }
    
    .chat-container {
      flex: 1;
      min-width: 300px;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .chat-messages {
      flex: 1;
      min-height: 400px;
      max-height: 70vh;
      overflow-y: auto;
      padding: 15px;
      background-color: #f5f5f5;
    }
    
    .message {
      margin-bottom: 15px;
      padding: 10px 15px;
      border-radius: 5px;
      max-width: 85%;
      word-break: break-word;
    }
    
    .message.user {
      background-color: #007bff;
      color: white;
      align-self: flex-end;
      margin-left: auto;
    }
    
    .message.ai {
      background-color: #e9ecef;
      color: #212529;
      align-self: flex-start;
    }
    
    .message.system {
      background-color: #ffc107;
      color: #212529;
      width: 100%;
      max-width: 100%;
      text-align: center;
      font-style: italic;
    }
    
    .chat-input {
      display: flex;
      padding: 10px;
      background-color: #fff;
      border-top: 1px solid #ddd;
    }
    
    .chat-input textarea {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      min-height: 60px;
      resize: vertical;
    }
    
    .chat-input button {
      padding: 0 20px;
      margin-left: 10px;
      border: none;
      background-color: #007bff;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .editor-container {
      flex: 2;
      min-width: 500px;
      display: flex;
      flex-direction: column;
    }
    
    .editor-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
    }
    
    .editor-tab {
      padding: 10px 15px;
      cursor: pointer;
      border: 1px solid transparent;
      border-radius: 5px 5px 0 0;
      background-color: #f8f9fa;
      margin-right: 5px;
      font-size: 0.9em;
    }
    
    .editor-tab.active {
      background-color: #fff;
      border-color: #ddd;
      border-bottom-color: #fff;
      z-index: 1;
      margin-bottom: -1px;
      font-weight: bold;
    }
    
    .editor-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      background-color: #f8f9fa;
      padding: 0 10px;
    }
    
    .tab-content {
      display: none;
      height: calc(100% - 43px);
      overflow: auto;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .editor-content {
      flex: 1;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    
    .editor-content.side-by-side {
      display: flex;
      padding: 0;
      gap: 15px;
      min-height: 500px;
    }
    
    .editor-pane, .preview-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .pane-header {
      padding: 10px 15px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #ddd;
      font-weight: bold;
      color: #495057;
    }
    
    .editor-textarea {
      width: 100%;
      height: 100%;
      border: none;
      padding: 15px;
      font-family: monospace;
      resize: none;
      font-size: 14px;
      line-height: 1.5;
    }
    
    .button-group {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    
    .button-group button {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .button-group button.primary {
      background-color: #007bff;
      color: white;
    }
    
    .button-group button.secondary {
      background-color: #6c757d;
      color: white;
    }
    
    .button-group button.success {
      background-color: #28a745;
      color: white;
    }
    
    .loading-spinner {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .preview-container {
      margin-top: 20px;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 20px;
      background-color: #fff;
    }
    
    .preview-container h2 {
      margin-top: 0;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    
    .preview-content {
      background-color: #fff;
      padding: 15px;
      flex: 1;
      overflow-y: auto;
      line-height: 1.6;
    }
    
    .preview-content img {
      max-width: 100%;
    }
    
    .preview-content h1, .preview-content h2, .preview-content h3 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }
    
    .preview-content code {
      background-color: #f5f5f5;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: monospace;
    }
    
    .preview-content pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    
    /* Modal styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background-color: #fff;
      border-radius: 5px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      border-bottom: 1px solid #ddd;
    }
    
    .modal-header h3 {
      margin: 0;
    }
    
    .close-modal {
      font-size: 24px;
      cursor: pointer;
      color: #aaa;
    }
    
    .close-modal:hover {
      color: #333;
    }
    
    .modal-body {
      padding: 15px;
      overflow-y: auto;
      flex: 1;
    }
    
    /* Version history styles */
    .version-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .version-item {
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .version-item:hover {
      background-color: #f5f5f5;
    }
    
    .version-item.active {
      background-color: #e3f2fd;
      border-left: 3px solid #2196F3;
    }
    
    .version-info {
      flex: 1;
    }
    
    .version-time {
      color: #666;
      font-size: 0.9em;
    }
    
    .version-actions {
      display: flex;
      gap: 5px;
    }
    
    /* Diff view styles */
    .diff-container {
      margin: 0;
      border: none;
      overflow: hidden;
      height: 100%;
    }
    
    .diff-header {
      padding: 10px 15px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #ddd;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .diff-header h4 {
      margin: 0 0 10px 0;
    }
    
    .diff-legend {
      display: flex;
      gap: 15px;
      font-size: 0.9em;
    }
    
    .diff-removed {
      color: #d32f2f;
      position: relative;
      padding-left: 15px;
    }
    
    .diff-removed::before {
      content: "-";
      position: absolute;
      left: 0;
      font-weight: bold;
    }
    
    .diff-added {
      color: #388e3c;
      position: relative;
      padding-left: 15px;
    }
    
    .diff-added::before {
      content: "+";
      position: absolute;
      left: 0;
      font-weight: bold;
    }
    
    .diff-content {
      height: calc(100% - 110px);
      overflow-y: auto;
      background-color: #fff;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.5;
      padding: 10px 0;
    }
    
    .diff-line {
      padding: 2px 15px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .diff-line.diff-removed {
      background-color: #ffebee;
      text-decoration: line-through;
    }
    
    .diff-line.diff-added {
      background-color: #e8f5e9;
    }
    
    .diff-actions {
      padding: 10px 15px;
      background-color: #f8f9fa;
      border-top: 1px solid #ddd;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      position: sticky;
      bottom: 0;
    }
    
    .diff-actions button {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .diff-actions .apply-changes {
      background-color: #2196F3;
      color: white;
    }
    
    .diff-actions .close-diff {
      background-color: #6c757d;
      color: white;
    }
    
    .diff-highlight {
      background-color: #ffffcc;
    }
    
    /* Inline diff styles */
    .inline-diff-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      font-family: monospace;
      overflow: hidden;
    }
    
    .blog-metadata {
      margin-bottom: 20px;
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #007bff;
    }
    
    .blog-metadata h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #495057;
    }
    
    .metadata-form {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    .metadata-form .field {
      display: flex;
      flex-direction: column;
    }
    
    .metadata-form label {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .metadata-form select,
    .metadata-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
{% endblock %}

{% block breadcrumbs %}
<div class="breadcrumbs">
  <a href="{% url 'admin:index' %}">Home</a>
  &rsaquo; <a href="{% url 'admin:app_list' app_label='blog' %}">Blog</a>
  &rsaquo; AI Blog Editor
</div>
{% endblock %}

{% block content %}
<div class="module aligned">
  <h1>AI Blog Editor</h1>
  
  {% if not api_key_configured %}
    <div class="errornote">
      <h3>API Key Not Configured</h3>
      <p>The Anthropic API key is required for AI-powered blog editing.</p>
      <p>To set up your API key:</p>
      <ol>
        <li>Go to the <a href="/admin/api-key-setup/">API Key Setup page</a></li>
        <li>Enter your Anthropic API key in the form</li>
        <li>Save the key to enable AI-powered editing</li>
      </ol>
      <a href="/admin/api-key-setup/" class="button" style="background-color: #28a745;">
        Configure API Key
      </a>
    </div>
  {% else %}
  
  <div class="ai-blog-editor-container">
    <!-- Chat container -->
    <div class="chat-container">
      <div class="chat-messages" id="chatMessages">
        <div class="message ai">
          <p>Hello! I'm your AI blog post assistant. Tell me what you'd like to write about, and I'll help you create a fantastic blog post. You can ask for specific changes, suggestions, or guidance at any point.</p>
          <p>The editor has two tabs: <strong>Plain Text</strong> for editing your content and <strong>Diff View</strong> for seeing suggested changes highlighted. Your markdown preview is always visible on the right.</p>
        </div>
      </div>
      
      <div class="chat-input">
        <textarea id="userInput" placeholder="Describe your blog post idea or ask for help..."></textarea>
        <button id="sendButton">Send</button>
      </div>
    </div>
    
    <!-- Editor container -->
    <div class="editor-container">
      <!-- Blog post metadata -->
      <div class="blog-metadata">
        <h3>Blog Post Details</h3>
        <div class="metadata-form">
          <div class="field">
            <label for="postTitle">Title</label>
            <input type="text" id="postTitle" name="title" placeholder="Enter blog post title">
          </div>
          
          <div class="field">
            <label for="postCategory">Category</label>
            <select id="postCategory" name="category">
              <option value="">-- Select Category --</option>
              {% for category in categories %}
                <option value="{{ category.id }}">{{ category.name }}</option>
              {% endfor %}
            </select>
          </div>
          
          <div class="field">
            <label for="postAuthor">Author</label>
            <select id="postAuthor" name="author">
              {% for author in authors %}
                <option value="{{ author.id }}">{{ author.get_full_name|default:author.username }}</option>
              {% endfor %}
            </select>
          </div>
          
          <div class="field">
            <label for="postStatus">Status</label>
            <select id="postStatus" name="status">
              <option value="draft">Draft</option>
              <option value="published">Published</option>
            </select>
          </div>
        </div>
      </div>
      
      <!-- Side-by-side editor and preview -->
      <div class="editor-content side-by-side">
        <div class="editor-pane">
          <div class="editor-tabs">
            <div class="editor-tab active" data-tab="editor">Plain Text</div>
            <div class="editor-tab" data-tab="diff">Diff View</div>
          </div>
          
          <div class="tab-content active" id="editorTab">
            <textarea id="postContent" class="editor-textarea" placeholder="Your blog post content in markdown format..."></textarea>
          </div>
          
          <div class="tab-content" id="diffTab" style="display: none; overflow: auto; height: 100%;">
            <!-- Diff content will be displayed here -->
            <div class="diff-placeholder">
              <p style="padding: 15px; text-align: center; color: #6c757d;">
                No changes to display. Use "Suggest Improvements" to see content differences.
              </p>
            </div>
          </div>
        </div>
        
        <div class="preview-pane">
          <div class="pane-header">Markdown Preview</div>
          <div id="previewContent" class="preview-content"></div>
        </div>
      </div>
      
      <!-- Button group -->
      <div class="button-group">
        <div>
          <button id="previewButton" class="secondary">Refresh Preview</button>
          <button id="suggestImprovements" class="secondary">Suggest Improvements</button>
          <button id="undoButton" class="secondary" disabled>Undo</button>
          <button id="redoButton" class="secondary" disabled>Redo</button>
          <span id="versionInfo" style="margin-left: 10px; color: #6c757d; font-size: 0.9em;">Version: 1</span>
        </div>
        <div>
          <button id="historyButton" class="secondary">History</button>
          <button id="saveButton" class="success">Save Post</button>
        </div>
      </div>
      
      <!-- Version history modal -->
      <div id="historyModal" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h3>Version History</h3>
            <span class="close-modal">&times;</span>
          </div>
          <div class="modal-body">
            <div id="versionList" class="version-list"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Hidden form for saving -->
  <form id="saveForm" method="post" action="{% url 'blog:save_ai_blog' %}" style="display: none;">
    {% csrf_token %}
    <input type="hidden" name="title" id="formTitle">
    <input type="hidden" name="content" id="formContent">
    <input type="hidden" name="author" id="formAuthor">
    <input type="hidden" name="category" id="formCategory">
    <input type="hidden" name="status" id="formStatus">
  </form>
  
  <!-- Loading spinner -->
  <div id="loadingSpinner" class="loading-spinner">
    <div class="spinner"></div>
    <p id="loadingMessage">Processing your request...</p>
  </div>
  
  <script>
    /**
     * AI Blog Editor JavaScript
     * 
     * This script powers the interactive AI-assisted blog post editor.
     * Key features:
     * - Real-time conversation with AI to generate and refine content
     * - Dynamic content updates in the editor from AI suggestions
     * - Preview rendering of markdown content
     * - Content improvement suggestions with diff view
     * - Side-by-side difference comparisons
     * - Toggle previews of improvements
     */
    document.addEventListener('DOMContentLoaded', function() {
      // DOM elements
      const chatMessages = document.getElementById('chatMessages');
      const userInput = document.getElementById('userInput');
      const sendButton = document.getElementById('sendButton');
      const postContent = document.getElementById('postContent');
      const postTitle = document.getElementById('postTitle');
      const postCategory = document.getElementById('postCategory');
      const postAuthor = document.getElementById('postAuthor');
      const postStatus = document.getElementById('postStatus');
      const previewButton = document.getElementById('previewButton');
      const previewContent = document.getElementById('previewContent');
      const saveButton = document.getElementById('saveButton');
      const loadingSpinner = document.getElementById('loadingSpinner');
      const loadingMessage = document.getElementById('loadingMessage');
      const suggestImprovements = document.getElementById('suggestImprovements');
      const undoButton = document.getElementById('undoButton');
      const redoButton = document.getElementById('redoButton');
      const versionInfo = document.getElementById('versionInfo');
      const historyButton = document.getElementById('historyButton');
      const historyModal = document.getElementById('historyModal');
      const versionList = document.getElementById('versionList');
      const closeModal = document.querySelector('.close-modal');
      
      // Initialize the preview on page load
      setTimeout(updatePreview, 500);
      
      /**
       * Version History System
       * 
       * This object manages a complete version history for content in the editor,
       * providing undo/redo functionality and a full history browser.
       * 
       * Key features:
       * - Tracks all content changes with timestamps and source info
       * - Provides undo/redo functionality with UI updates
       * - Offers a version browser with diff view for comparing changes
       * - Supports restoring any historical version
       * - Auto-detects content changes and creates versions intelligently
       */
      /**
       * Storage Manager for persisting editor state
       * 
       * This module provides persistent storage for the AI blog editor, ensuring content 
       * isn't lost when navigating away or refreshing. It uses browser's localStorage 
       * with these key features:
       * 
       * - Automatically saves all editor state (content, metadata, history, chat)
       * - Restores previous session when returning to editor
       * - Provides 24-hour expiration for abandoned drafts
       * - Includes complete version history persistence
       * - Preserves tab state and scroll positions
       * - Maintains chat history for context continuity
       */
      const storageManager = {
        // Keys for localStorage - comprehensive coverage of all editor state
        KEYS: {
          CONTENT: 'ai_blog_editor_content',          // The actual markdown content
          TITLE: 'ai_blog_editor_title',              // Post title field
          CATEGORY: 'ai_blog_editor_category',        // Selected category ID
          AUTHOR: 'ai_blog_editor_author',            // Selected author ID
          STATUS: 'ai_blog_editor_status',            // Post status (draft/published)
          VERSION_HISTORY: 'ai_blog_editor_version_history',  // Complete version history array
          CURRENT_INDEX: 'ai_blog_editor_current_index',      // Current position in version history
          ACTIVE_TAB: 'ai_blog_editor_active_tab',    // Which tab is active (editor/diff)
          CHAT_HISTORY: 'ai_blog_editor_chat_history',// Complete conversation history
          LAST_EDITED: 'ai_blog_editor_last_edited',  // Timestamp for expiration check
          DIFF_PREVIOUS: 'ai_blog_editor_diff_previous', // Content for diff comparison (before)
          DIFF_CURRENT: 'ai_blog_editor_diff_current'    // Content for diff comparison (after)
        },
        
        /**
         * Saves the entire editor state to localStorage
         * Captures all aspects of editor state for complete session persistence
         */
        saveEditorState() {
          const now = new Date();
          
          // Save basic content and metadata
          localStorage.setItem(this.KEYS.CONTENT, postContent.value);
          localStorage.setItem(this.KEYS.TITLE, postTitle.value);
          localStorage.setItem(this.KEYS.CATEGORY, postCategory.value);
          localStorage.setItem(this.KEYS.AUTHOR, postAuthor.value);
          localStorage.setItem(this.KEYS.STATUS, postStatus.value);
          
          // Save version history - enables complete undo/redo functionality
          localStorage.setItem(this.KEYS.VERSION_HISTORY, JSON.stringify(versionHistory.versions));
          localStorage.setItem(this.KEYS.CURRENT_INDEX, versionHistory.currentIndex);
          
          // Save active tab - maintains UI state
          const activeTab = document.querySelector('.editor-tab.active').getAttribute('data-tab');
          localStorage.setItem(this.KEYS.ACTIVE_TAB, activeTab);
          
          // Save chat history - preserves complete conversation context
          const chatMessages = Array.from(document.querySelectorAll('#chatMessages .message'))
            .map(msg => {
              const type = msg.classList.contains('user') ? 'user' : 
                          msg.classList.contains('ai') ? 'ai' : 'system';
              return {
                type: type,
                content: msg.querySelector('p').innerHTML
              };
            });
          localStorage.setItem(this.KEYS.CHAT_HISTORY, JSON.stringify(chatMessages));
          
          // Save timestamp for expiration check (24-hour drafts)
          localStorage.setItem(this.KEYS.LAST_EDITED, now.toISOString());
          
          console.log('Editor state saved to localStorage at:', now);
        },
        
        /**
         * Loads the entire editor state from localStorage
         * Provides complete session restoration with safety checks
         * 
         * @returns {boolean} Whether there was state to restore
         */
        loadEditorState() {
          const content = localStorage.getItem(this.KEYS.CONTENT);
          
          // If no content, nothing to restore
          if (!content) {
            console.log('No saved editor state found in localStorage');
            return false;
          }
          
          // Get timestamp and check if it's recent (within 24 hours)
          // This prevents cluttering with abandoned drafts
          const lastEdited = localStorage.getItem(this.KEYS.LAST_EDITED);
          const now = new Date();
          const lastEditedDate = lastEdited ? new Date(lastEdited) : null;
          
          // If it's been more than 24 hours, don't restore (start fresh)
          if (lastEditedDate && (now - lastEditedDate) > (24 * 60 * 60 * 1000)) {
            console.log('Saved state is older than 24 hours, starting fresh');
            this.clearEditorState();
            return false;
          }
          
          // Restore basic content and metadata with fallbacks to defaults
          const originalContent = content;
          postContent.value = content;
          postTitle.value = localStorage.getItem(this.KEYS.TITLE) || '';
          postCategory.value = localStorage.getItem(this.KEYS.CATEGORY) || '';
          postAuthor.value = localStorage.getItem(this.KEYS.AUTHOR) || '';
          postStatus.value = localStorage.getItem(this.KEYS.STATUS) || 'draft';
          
          // Restore version history with complete undo/redo capability
          const savedVersions = localStorage.getItem(this.KEYS.VERSION_HISTORY);
          const savedCurrentIndex = localStorage.getItem(this.KEYS.CURRENT_INDEX);
          
          if (savedVersions && savedCurrentIndex) {
            try {
              const parsedVersions = JSON.parse(savedVersions);
              
              // Convert string timestamps back to Date objects
              // JSON.stringify doesn't preserve Date objects, so we need to reconstitute them
              parsedVersions.forEach(v => {
                v.timestamp = new Date(v.timestamp);
              });
              
              versionHistory.versions = parsedVersions;
              versionHistory.currentIndex = parseInt(savedCurrentIndex, 10);
              versionHistory.updateUI();
              
              // Check if we have stored diff content for diff view
              const storedPrevious = localStorage.getItem(this.KEYS.DIFF_PREVIOUS);
              const storedCurrent = localStorage.getItem(this.KEYS.DIFF_CURRENT);
              
              if (storedPrevious && storedCurrent) {
                // Restore the diff view from stored diff content
                prepareDiffView(storedPrevious, storedCurrent);
                console.log('Restored diff view from saved diff content');
              } 
              // If no stored diff content, but we have version history
              else if (parsedVersions.length >= 2) {
                const currentVersion = parsedVersions[versionHistory.currentIndex].content;
                
                // Find the previous version (either previous in history or original for comparison)
                let previousVersionIndex = versionHistory.currentIndex - 1;
                if (previousVersionIndex < 0) previousVersionIndex = 0;
                
                const previousVersion = parsedVersions[previousVersionIndex].content;
                
                // Restore diff view with the most recent change
                prepareDiffView(previousVersion, currentVersion);
                
                console.log('Restored diff view comparing version', previousVersionIndex + 1, 'to version', versionHistory.currentIndex + 1);
              } else if (parsedVersions.length === 1) {
                // Just a single version, show a placeholder diff with just this content
                const diffTab = document.getElementById('diffTab');
                diffTab.innerHTML = `
                  <div class="diff-placeholder">
                    <p style="padding: 15px; text-align: center; color: #6c757d;">
                      No changes to compare yet. Make some edits or use "Suggest Improvements" to see content differences.
                    </p>
                  </div>
                `;
              }
            } catch (e) {
              console.error('Error parsing saved version history:', e);
            }
          }
          
          // Restore active tab - maintains UI state between sessions
          const activeTab = localStorage.getItem(this.KEYS.ACTIVE_TAB) || 'editor';
          document.querySelector(`.editor-tab[data-tab="${activeTab}"]`).click();
          
          // Restore chat history - preserves conversation context between sessions
          const chatHistoryJSON = localStorage.getItem(this.KEYS.CHAT_HISTORY);
          if (chatHistoryJSON) {
            try {
              const chatHistory = JSON.parse(chatHistoryJSON);
              
              // Clear existing messages
              const chatMessagesContainer = document.getElementById('chatMessages');
              chatMessagesContainer.innerHTML = '';
              
              // Add saved messages
              chatHistory.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${msg.type}`;
                messageDiv.innerHTML = `<p>${msg.content}</p>`;
                chatMessagesContainer.appendChild(messageDiv);
              });
            } catch (e) {
              console.error('Error parsing saved chat history:', e);
            }
          }
          
          // Update preview
          updatePreview();
          
          console.log('Editor state restored from localStorage (last edited:', lastEdited, ')');
          return true;
        },
        
        /**
         * Clears all saved editor state from localStorage
         * Used when starting fresh or when draft is explicitly discarded
         */
        clearEditorState() {
          Object.values(this.KEYS).forEach(key => {
            localStorage.removeItem(key);
          });
          console.log('Editor state cleared from localStorage');
        }
      };
    
      const versionHistory = {
        versions: [], // Array to store all versions of content
        currentIndex: -1, // Current position in version history
        
        /**
         * Initialize the version history with the current content
         * Creates the first version (baseline) for the undo/redo system
         */
        init() {
          // Only initialize if there's no saved state
          if (this.versions.length === 0) {
            this.addVersion(postContent.value);
          }
        },
        
        /**
         * Add a new version to the history
         * 
         * @param {string} content - The content to add as a new version
         * @param {string} source - The source of the change ('edit', 'ai', 'undo', 'redo', 'restore')
         * @returns {boolean} - Whether a new version was added
         */
        addVersion(content, source = 'edit') {
          // Don't add duplicate content (same as current version)
          if (this.currentIndex >= 0 && this.versions[this.currentIndex].content === content) {
            return false;
          }
          
          // If we're not at the latest version (user did an undo),
          // remove all versions after current position (standard undo/redo behavior)
          if (this.currentIndex < this.versions.length - 1) {
            this.versions = this.versions.slice(0, this.currentIndex + 1);
          }
          
          // Add the new version with metadata
          this.versions.push({
            content: content,
            timestamp: new Date(),
            source: source  // Tracks where the change came from
          });
          
          // Update current index to point to the new version
          this.currentIndex = this.versions.length - 1;
          
          // Update UI to reflect the new version state
          this.updateUI();
          
          // Save state to localStorage
          storageManager.saveEditorState();
          
          return true;
        },
        
        /**
         * Moves back one version in history (undo operation)
         * 
         * @returns {boolean} - Whether the undo was successful
         */
        undo() {
          // Check if we can go back (not at the beginning of history)
          if (this.currentIndex > 0) {
            this.currentIndex--; // Move back one version
            postContent.value = this.versions[this.currentIndex].content; // Update editor content
            updatePreview(); // Update preview to reflect content
            this.updateUI(); // Update UI elements
            
            // Save state to localStorage
            storageManager.saveEditorState();
            
            return true;
          }
          return false; // Can't undo (at first version)
        },
        
        /**
         * Moves forward one version in history (redo operation)
         * 
         * @returns {boolean} - Whether the redo was successful
         */
        redo() {
          // Check if we can go forward (not at the end of history)
          if (this.currentIndex < this.versions.length - 1) {
            this.currentIndex++; // Move forward one version
            postContent.value = this.versions[this.currentIndex].content; // Update editor content
            updatePreview(); // Update preview to reflect content
            this.updateUI(); // Update UI elements 
            
            // Save state to localStorage
            storageManager.saveEditorState();
            
            return true;
          }
          return false; // Can't redo (at last version)
        },
        
        /**
         * Restores a specific version from history by index
         * 
         * @param {number} index - The index of the version to restore
         * @returns {boolean} - Whether the restore was successful
         */
        restoreVersion(index) {
          // Validate index
          if (index >= 0 && index < this.versions.length) {
            // If restoring a previous version, add current as a new version first
            // This allows going back to the current state after restoring
            if (index !== this.currentIndex) {
              // First record where we're restoring from in the history
              this.versions.push({
                content: this.versions[index].content,
                timestamp: new Date(),
                source: 'restore'  // Mark as a restored version
              });
              this.currentIndex = this.versions.length - 1;
            }
            
            // Update content and UI
            postContent.value = this.versions[index].content;
            updatePreview();
            this.updateUI();
            
            // Save state to localStorage
            storageManager.saveEditorState();
            
            return true;
          }
          return false; // Invalid index
        },
        
        /**
         * Updates the UI elements to reflect the current version state
         * - Enables/disables undo/redo buttons based on position in history
         * - Updates version counter display
         * - Refreshes history modal if it's open
         */
        updateUI() {
          // Update undo/redo buttons state
          undoButton.disabled = this.currentIndex <= 0; // Disable undo if at first version
          redoButton.disabled = this.currentIndex >= this.versions.length - 1; // Disable redo if at last version
          
          // Update version info counter
          versionInfo.textContent = `Version: ${this.currentIndex + 1} of ${this.versions.length}`;
          
          // Update version history list if the modal is open
          if (historyModal.style.display === 'flex') {
            this.renderVersionList();
          }
        },
        
        // Render the version list in the history modal
        renderVersionList() {
          versionList.innerHTML = '';
          
          this.versions.forEach((version, index) => {
            const isActive = index === this.currentIndex;
            const formattedTime = this.formatTimestamp(version.timestamp);
            const sourceLabel = this.getSourceLabel(version.source);
            
            const versionItem = document.createElement('div');
            versionItem.className = `version-item ${isActive ? 'active' : ''}`;
            versionItem.innerHTML = `
              <div class="version-info">
                <div>Version ${index + 1} (${sourceLabel})</div>
                <div class="version-time">${formattedTime}</div>
              </div>
              <div class="version-actions">
                <button class="restore-btn ${isActive ? 'disabled' : ''}" ${isActive ? 'disabled' : ''}>Restore</button>
              </div>
            `;
            
            // Add event listener for restore button
            const restoreBtn = versionItem.querySelector('.restore-btn');
            if (!isActive) {
              restoreBtn.addEventListener('click', (e) => {
                e.stopPropagation();  // Prevent item click from firing
                this.restoreVersion(index);
                historyModal.style.display = 'none';
              });
            }
            
            // Add event listener for item click (preview)
            versionItem.addEventListener('click', () => {
              // Highlight the active item
              document.querySelectorAll('.version-item').forEach(item => {
                item.classList.remove('active');
              });
              versionItem.classList.add('active');
              
              // Show diff between current and selected version
              this.showDiff(index);
            });
            
            versionList.appendChild(versionItem);
          });
        },
        
        // Format timestamp for display
        formatTimestamp(timestamp) {
          const now = new Date();
          const diff = now - timestamp;
          
          // If less than a minute ago, show 'just now'
          if (diff < 60000) {
            return 'just now';
          }
          
          // If less than an hour ago, show minutes
          if (diff < 3600000) {
            const minutes = Math.floor(diff / 60000);
            return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
          }
          
          // Otherwise, show the time
          return timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        },
        
        // Get a human-readable label for the source
        getSourceLabel(source) {
          const labels = {
            'edit': 'Manual Edit',
            'ai': 'AI Generated',
            'undo': 'Undo',
            'redo': 'Redo',
            'restore': 'Restored'
          };
          
          return labels[source] || 'Edit';
        },
        
        // Show diff between two versions
        showDiff(index) {
          if (index < 0 || index >= this.versions.length) return;
          
          const currentContent = this.versions[this.currentIndex].content;
          const selectedContent = this.versions[index].content;
          
          // Create a diff view to show changes
          const diffContainer = document.createElement('div');
          diffContainer.className = 'diff-container';
          
          // Add header with information about the versions
          const diffHeader = document.createElement('div');
          diffHeader.className = 'diff-header';
          diffHeader.innerHTML = `
            <h4>Changes between Version ${index + 1} and Version ${this.currentIndex + 1}</h4>
            <div class="diff-legend">
              <span class="diff-removed">Removed</span>
              <span class="diff-added">Added</span>
            </div>
          `;
          diffContainer.appendChild(diffHeader);
          
          // Split content into lines
          const currentLines = currentContent.split('\n');
          const selectedLines = selectedContent.split('\n');
          
          // Simple line-by-line diff
          const diffContent = document.createElement('div');
          diffContent.className = 'diff-content';
          
          // Find the max length of both arrays
          const maxLines = Math.max(currentLines.length, selectedLines.length);
          
          for (let i = 0; i < maxLines; i++) {
            const currentLine = i < currentLines.length ? currentLines[i] : '';
            const selectedLine = i < selectedLines.length ? selectedLines[i] : '';
            
            if (currentLine !== selectedLine) {
              // Lines are different
              if (selectedLine) {
                const oldLine = document.createElement('div');
                oldLine.className = 'diff-line diff-removed';
                oldLine.textContent = selectedLine;
                diffContent.appendChild(oldLine);
              }
              
              if (currentLine) {
                const newLine = document.createElement('div');
                newLine.className = 'diff-line diff-added';
                newLine.textContent = currentLine;
                diffContent.appendChild(newLine);
              }
            } else {
              // Lines are the same
              const unchangedLine = document.createElement('div');
              unchangedLine.className = 'diff-line';
              unchangedLine.textContent = currentLine;
              diffContent.appendChild(unchangedLine);
            }
          }
          
          diffContainer.appendChild(diffContent);
          
          // Add actions buttons
          const diffActions = document.createElement('div');
          diffActions.className = 'diff-actions';
          diffActions.innerHTML = `
            <button class="restore-version">Restore Version ${index + 1}</button>
            <button class="close-diff">Close</button>
          `;
          diffContainer.appendChild(diffActions);
          
          // Add event listeners for buttons
          diffActions.querySelector('.restore-version').addEventListener('click', () => {
            this.restoreVersion(index);
            
            // Remove the diff view
            if (document.querySelector('.diff-container')) {
              document.querySelector('.diff-container').remove();
            }
          });
          
          diffActions.querySelector('.close-diff').addEventListener('click', () => {
            // Remove the diff view
            if (document.querySelector('.diff-container')) {
              document.querySelector('.diff-container').remove();
            }
          });
          
          // Remove any existing diff view
          if (document.querySelector('.diff-container')) {
            document.querySelector('.diff-container').remove();
          }
          
          // Add the diff view to the modal
          document.querySelector('.modal-body').appendChild(diffContainer);
        }
      };
      
      // Initialize version history and attempt to restore previous state
      setTimeout(() => {
        // Try to restore previous state from localStorage
        const stateRestored = storageManager.loadEditorState();
        
        // If no saved state was found, create a new initial version
        if (!stateRestored) {
          versionHistory.init();
        }
        
        // Add a "Clear Draft" button for starting fresh with a clean editor
        // This is an important companion feature to the localStorage persistence
        // system, allowing users to explicitly discard saved drafts when needed
        const buttonGroup = document.querySelector('.button-group div:last-child');
        const clearDraftBtn = document.createElement('button');
        clearDraftBtn.className = 'secondary';
        clearDraftBtn.textContent = 'Clear Draft';
        clearDraftBtn.style.marginRight = '10px';
        clearDraftBtn.title = 'Discard the current draft and all history'; // Add tooltip
        
        // Set up confirmation dialog to prevent accidental clearing
        clearDraftBtn.addEventListener('click', function() {
          if (confirm('Are you sure you want to clear this draft? This will delete all content and history.')) {
            // Clear all localStorage data associated with this editor
            storageManager.clearEditorState();
            // Reload the page to start fresh with a clean editor state
            window.location.reload();
          }
        });
        buttonGroup.prepend(clearDraftBtn);
        
        // Set up synchronized scrolling between editor and preview panes
        // This ensures that as you scroll in one pane, the other follows proportionally
        let isEditorScrolling = false;
        let isPreviewScrolling = false;
        
        /**
         * Synchronized Scrolling System
         * 
         * This feature coordinates scrolling between the editor and preview panes
         * to create a unified reading/editing experience by:
         * 
         * 1. Tracking scroll position ratios rather than absolute positions
         * 2. Using mutual-exclusion flags to prevent scroll feedback loops
         * 3. Matching relative positions between panes of different heights
         * 4. Providing a smooth, natural scrolling experience in both directions
         */
        
        // When editor scrolls, update preview scroll position
        postContent.addEventListener('scroll', function() {
          // Only proceed if not already handling a preview-initiated scroll
          if (!isPreviewScrolling) {
            isEditorScrolling = true;
            
            // Calculate the scroll ratio (how far through the content we are)
            // This approach handles different content heights between panes
            const ratio = this.scrollTop / (this.scrollHeight - this.clientHeight);
            
            // Apply the same proportional position to the preview
            const previewScrollTop = ratio * (previewContent.scrollHeight - previewContent.clientHeight);
            previewContent.scrollTop = previewScrollTop;
            
            // Reset the flag after a short delay to allow scroll to complete
            setTimeout(() => {
              isEditorScrolling = false;
            }, 50);
          }
        });
        
        // When preview scrolls, update editor scroll position
        previewContent.addEventListener('scroll', function() {
          // Only proceed if not already handling an editor-initiated scroll
          if (!isEditorScrolling) {
            isPreviewScrolling = true;
            
            // Calculate the scroll ratio using the same approach
            const ratio = this.scrollTop / (this.scrollHeight - this.clientHeight);
            
            // Apply the same proportional position to the editor
            const editorScrollTop = ratio * (postContent.scrollHeight - postContent.clientHeight);
            postContent.scrollTop = editorScrollTop;
            
            // Reset the flag after a short delay to allow scroll to complete
            setTimeout(() => {
              isPreviewScrolling = false;
            }, 50);
          }
        });
      }, 1000);
      
      // CSRF token function
      function getCsrfToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]').value;
      }
      
      // Add message to chat
      function addMessage(content, type) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.innerHTML = `<p>${content}</p>`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // Save state after adding a message
        storageManager.saveEditorState();
      }
      
      /**
       * Scroll-Preserving Preview System
       * 
       * Renders markdown content as HTML in the preview pane while intelligently
       * preserving scroll position to prevent jarring jumps during editing.
       * 
       * This system solves the common problem of lost scroll position during 
       * content updates by:
       * 
       * 1. Capturing scroll positions in both editor and preview panes
       * 2. Computing relative position ratios that are content-length independent
       * 3. Updating content with non-blocking, smooth transitions
       * 4. Intelligently determining which pane's position to preserve based on focus
       * 5. Handling errors gracefully without disrupting the user experience
       * 
       * This creates a seamless editing experience where content updates don't
       * interrupt the user's focus or reading position.
       */
      function updatePreview() {
        // Store current scroll positions and heights for both panes
        const editorScrollTop = postContent.scrollTop;
        const editorScrollHeight = postContent.scrollHeight;
        const previewScrollTop = previewContent.scrollTop;
        const previewScrollHeight = previewContent.scrollHeight;
        
        // Calculate scroll ratios for position-independent restoration
        // Adding max() with 1 prevents division by zero if content is too short to scroll
        const editorScrollRatio = editorScrollTop / Math.max(editorScrollHeight - postContent.clientHeight, 1);
        const previewScrollRatio = previewScrollTop / Math.max(previewScrollHeight - previewContent.clientHeight, 1);
        
        // Create a non-intrusive loading indicator that doesn't disrupt layout
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'preview-loading';
        loadingIndicator.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; border-width: 2px; display: inline-block; margin-right: 5px;"></div> Updating...';
        loadingIndicator.style.cssText = 'position: absolute; top: 5px; right: 5px; background: rgba(255,255,255,0.9); padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 100; box-shadow: 0 2px 4px rgba(0,0,0,0.1);';
        
        // Add loading indicator without disturbing existing content
        previewContent.parentNode.style.position = 'relative';
        previewContent.parentNode.appendChild(loadingIndicator);
        
        // Send content to server for markdown rendering
        fetch('{% url "blog:markdown_preview" %}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
          },
          body: JSON.stringify({
            content: postContent.value
          })
        })
        .then(response => response.json())
        .then(data => {
          // Update preview content with rendered HTML
          previewContent.innerHTML = data.html;
          
          // Remove loading indicator once content is loaded
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }
          
          // Restore scroll position after a tiny delay to allow DOM rendering
          setTimeout(() => {
            // Intelligently choose which position to preserve:
            // - If user is typing in editor, preserve editor's position
            // - If user was viewing/scrolling preview, preserve preview's position
            const ratio = document.activeElement === postContent ? editorScrollRatio : previewScrollRatio;
            
            // Calculate new absolute scroll position from ratio
            const newScrollTop = ratio * (previewContent.scrollHeight - previewContent.clientHeight);
            
            // Apply the scroll position without triggering scroll events
            previewContent.scrollTop = newScrollTop;
          }, 10);
        })
        .catch(error => {
          console.error('Error generating preview:', error);
          
          // Show a non-disruptive error message that preserves existing content
          const errorNotice = document.createElement('div');
          errorNotice.style.cssText = 'color: red; padding: 10px; margin: 10px 0; background: #ffebee; border-radius: 4px;';
          errorNotice.textContent = 'Error updating preview. Will retry on next edit.';
          previewContent.prepend(errorNotice);
          
          // Auto-remove error after a few seconds to avoid cluttering the interface
          setTimeout(() => {
            if (errorNotice.parentNode) {
              errorNotice.parentNode.removeChild(errorNotice);
            }
          }, 3000);
          
          // Always clean up the loading indicator, even on error
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }
        });
      }
      
      /**
       * Handles user message submission to the AI
       * 
       * This function:
       * 1. Sends the user's message to the AI along with the current blog state
       * 2. Shows a loading spinner during processing
       * 3. Adds the AI's response to the chat window
       * 4. Updates the editor content with the AI's blog post
       * 5. Updates the title field if a title is suggested
       * 6. Attempts to detect and set the category from content
       * 
       * The AI returns two sections:
       * - A conversational response shown in the chat
       * - A complete blog post that updates the editor
       */
      function handleUserMessage() {
        const message = userInput.value.trim();
        
        if (!message) {
          return;
        }
        
        // Add user message to chat
        addMessage(message, 'user');
        
        // Clear input
        userInput.value = '';
        
        // Show loading spinner
        loadingSpinner.style.display = 'flex';
        loadingMessage.textContent = 'AI is thinking...';
        
        // Get current content and metadata
        const title = postTitle.value;
        const content = postContent.value;
        const category = postCategory.options[postCategory.selectedIndex]?.text || '';
        
        /**
         * Smart Content Length Handling System
         * 
         * This system intelligently manages long content that might exceed AI token limits
         * by detecting content length and providing targeted editing options.
         * 
         * Key features:
         * 1. Dynamically calculates word count for user feedback
         * 2. Analyzes request type to determine if it can be processed as-is
         * 3. Offers specialized interactive UI for focused editing of sections
         * 4. Prevents failed requests by proactively suggesting alternatives
         * 5. Provides instant feedback with interactive solution options
         */
        
        // Check content length and display appropriate message
        const contentWordCount = content.split(/\s+/).length;
        const isVeryLong = content.length > 25000;
        
        if (isVeryLong) {
          loadingMessage.textContent = `AI is thinking... (Processing ${contentWordCount} words, may take longer)`;
          
          // Intelligently analyze the prompt to determine if it's already focused
          // This allows specific requests to proceed even with longer content
          const isSpecificRequest = message.match(/paragraph|section|sentence|line|heading|beginning|end|conclusion|introduction/i);
          const isEditRequest = message.match(/edit|change|replace|modify|update|rewrite/i);
          
          // Only trigger special handling for very large content with general requests
          // This prevents interrupting the user when they're already using a targeted approach
          if (!isSpecificRequest && !isEditRequest && content.length > 40000) {
            // Halt the current request to prevent a likely token limit error
            addMessage(`Your document is quite large (${contentWordCount} words), which may exceed the AI's processing limits for a full document review.`, 'system');
            addMessage(`For better results with long documents, try one of these approaches:`, 'system');
            
            // Create interactive UI with focused editing options
            // This provides users with an immediate solution rather than just an error
            const optionsMsg = document.createElement('div');
            optionsMsg.className = 'message system';
            optionsMsg.innerHTML = `
              <p>Choose a specific part to work on:</p>
              <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
                <button class="focus-btn" data-focus="intro" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Improve the introduction</button>
                <button class="focus-btn" data-focus="conclusion" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Enhance the conclusion</button>
                <button class="focus-btn" data-focus="clarity" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Improve overall clarity and flow</button>
                <button class="focus-btn" data-focus="structure" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Suggest better structure or organization</button>
              </div>
            `;
            chatMessages.appendChild(optionsMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Add event listeners to the focus buttons for interactive experience
            optionsMsg.querySelectorAll('.focus-btn').forEach(btn => {
              btn.addEventListener('click', function() {
                // Get the selected focus area from button data attribute
                const focusArea = this.getAttribute('data-focus');
                let newPrompt = '';
                
                // Generate appropriate targeted prompt based on selection
                switch(focusArea) {
                  case 'intro':
                    newPrompt = "Please improve the introduction of my blog post. Make it more engaging and clearly introduce the main topic.";
                    break;
                  case 'conclusion':
                    newPrompt = "Please improve the conclusion of my blog post. Summarize the key points and end with a strong takeaway.";
                    break;
                  case 'clarity':
                    newPrompt = "Please review my blog post for clarity and flow. Suggest specific improvements to make the content more readable, but don't rewrite the entire post.";
                    break;
                  case 'structure':
                    newPrompt = "Please analyze the structure of my blog post. Suggest a better organization if needed, with clear headings and logical flow between sections.";
                    break;
                }
                
                // Add the selected focus as a user message to maintain conversation flow
                addMessage(newPrompt, 'user');
                
                // Process with standard handler using the focused prompt
                // This ensures a consistent experience regardless of how the prompt was generated
                fetch('{% url "blog:ai_blog_conversation" %}', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                  },
                  body: JSON.stringify({
                    message: newPrompt,
                    title: title,
                    content: content,
                    category: category
                  })
                })
                .then(response => response.json())
                .then(data => handleAIResponse(data))
                .catch(error => {
                  console.error('Error:', error);
                  loadingSpinner.style.display = 'none';
                  addMessage('An error occurred while communicating with the AI. Please try again.', 'system');
                });
                
                // Show loading spinner for feedback
                loadingSpinner.style.display = 'flex';
                loadingMessage.textContent = 'AI is thinking...';
              });
            });
            
            // Hide loading spinner since we're not proceeding with original request
            loadingSpinner.style.display = 'none';
            
            // Don't proceed with the original request to prevent token limit errors
            return;
          }
        }
        
        // Send request to AI
        fetch('{% url "blog:ai_blog_conversation" %}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
          },
          body: JSON.stringify({
            message: message,
            title: title,
            content: content,
            category: category
          })
        })
        .then(response => response.json())
        .then(data => handleAIResponse(data))
        .catch(error => {
          console.error('Error:', error);
          loadingSpinner.style.display = 'none';
          addMessage('An error occurred while communicating with the AI. Please try again.', 'system');
        });
      }
      
      /**
       * Handles AI response processing
       * Extracted to a separate function so it can be reused for different request types
       */
      function handleAIResponse(data) {
        // Hide loading spinner
        loadingSpinner.style.display = 'none';
        
        if (data.error) {
          // Handle error
          addMessage(`Error: ${data.error}`, 'system');
          return;
        }
        
        // Add AI response to chat
        addMessage(data.reply, 'ai');
        
        // Update content if provided
        if (data.content) {
          console.log("Updating content with new content:", data.content.substring(0, 100) + "...");
          
          // Store the previous content for comparison
          const previousContent = postContent.value;
          const isFirstContent = !previousContent.trim();
          
          // Update editor with the new content
          postContent.value = data.content;
          
          // Update the preview as well
          updatePreview();
          
          // Add a new version to history
          versionHistory.addVersion(data.content, 'ai');
          
          // Add an appropriate system message based on whether this is the first content or an update
          if (isFirstContent) {
            addMessage(" Blog post created in the editor! You can now edit or refine it.", "system");
            
            // Add a hint about the side-by-side editor
            setTimeout(() => {
              addMessage("Tip: Your content appears in the editor on the left and the preview on the right. Changes update automatically.", "system");
            }, 1500);
          } else {
            // Create a message with buttons
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.innerHTML = `
              <p> Blog post updated in the editor</p>
              <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="view-diff-btn" style="background-color: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">View Changes in Diff Tab</button>
              </div>
            `;
            chatMessages.appendChild(messageDiv);
            
            // Prepare the diff view content
            prepareDiffView(previousContent, data.content);
            
            // Add event listener for the view diff button
            messageDiv.querySelector('.view-diff-btn').addEventListener('click', function() {
              // Switch to diff tab
              document.querySelector('.editor-tab[data-tab="diff"]').click();
            });
          }
        }
        
        // Update title if provided
        if (data.title) {
          console.log("Updating title to:", data.title);
          // Always update if empty or if overwrite flag is set
          if (!postTitle.value || data.overwrite_title) {
            postTitle.value = data.title;
            addMessage(`Title has been set to: "${data.title}"`, "system");
          } else {
            // Suggest the title but don't automatically change it
            addMessage(`Suggested title: "${data.title}" (click to use)`, "system");
            
            // Make the message clickable to update the title
            const messages = chatMessages.querySelectorAll('.message.system');
            const lastMessage = messages[messages.length - 1];
            lastMessage.style.cursor = 'pointer';
            lastMessage.addEventListener('click', function() {
              postTitle.value = data.title;
              this.innerHTML = `<p>Title has been updated to: "${data.title}"</p>`;
              this.style.backgroundColor = '#28a745';
              this.style.color = 'white';
              
              // Save state after title update
              storageManager.saveEditorState();
            });
          }
        }
        
        // Save the full state after processing AI response
        storageManager.saveEditorState();
        
        // If category is empty, try to extract from content
        if (!postCategory.value && typeof category !== 'undefined' && category === '') {
          // Look for category indicators in the content
          const categoryNames = Array.from(postCategory.options).map(opt => opt.text.toLowerCase());
          
          // Skip the first "Select Category" option
          categoryNames.shift();
          
          // Check if any category name is mentioned in the content or response
          const contentToCheck = (data.content || '') + ' ' + data.reply.toLowerCase();
          
          for (let i = 0; i < categoryNames.length; i++) {
            if (contentToCheck.toLowerCase().includes(categoryNames[i])) {
              // Found a category match
              const categoryOption = Array.from(postCategory.options).find(
                opt => opt.text.toLowerCase() === categoryNames[i]
              );
              
              if (categoryOption) {
                postCategory.value = categoryOption.value;
                addMessage(`Category set to: ${categoryOption.text}`, "system");
                break;
              }
            }
          }
        }
      }
      
      // Handle editor tab switching
      document.addEventListener('click', function(e) {
        // If the clicked element is an editor tab button
        if (e.target.classList.contains('editor-tab')) {
          const tabName = e.target.getAttribute('data-tab');
          
          // Remove active class from all tabs
          document.querySelectorAll('.editor-tab').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Add active class to the clicked tab
          e.target.classList.add('active');
          
          // Hide all tab contents
          document.querySelectorAll('.tab-content').forEach(content => {
            content.style.display = 'none';
          });
          
          // Show the selected tab content
          document.getElementById(tabName + 'Tab').style.display = 'block';
          
          // Special handling for diff tab - recreate the diff view with the latest versions
          if (tabName === 'diff' && versionHistory.versions.length >= 2) {
            // Get the current version
            const currentVersion = versionHistory.versions[versionHistory.currentIndex].content;
            
            // Find the best previous version to compare against
            let previousVersionIndex = versionHistory.currentIndex - 1;
            // If we're at the first version, compare with the same version (will show no changes)
            if (previousVersionIndex < 0) previousVersionIndex = 0;
            
            const previousVersion = versionHistory.versions[previousVersionIndex].content;
            
            // Create the diff view
            prepareDiffView(previousVersion, currentVersion);
            
            console.log('Generated diff view comparing version', previousVersionIndex + 1, 'to version', versionHistory.currentIndex + 1);
          }
          
          // Ensure focus returns to the editor if that tab is active
          if (tabName === 'editor') {
            postContent.focus();
          }
          
          // Save the current state with active tab
          storageManager.saveEditorState();
        }
      });
      
      /**
       * Requests and handles AI improvement suggestions for the current content
       * 
       * This function provides an advanced content improvement workflow:
       * 1. Sends the current content to the AI for analysis
       * 2. Displays the AI's improvement suggestions in the chat
       * 3. Shows differences in the Diff tab
       * 4. Provides options to apply or discard changes
       */
      function suggestPostImprovements() {
        const content = postContent.value.trim();
        
        if (!content) {
          alert('Please write some content first before requesting improvements.');
          return;
        }
        
        // Add message to chat
        addMessage('Can you suggest improvements for this content?', 'user');
        
        // Show loading spinner
        loadingSpinner.style.display = 'flex';
        loadingMessage.textContent = 'Analyzing your content...';
        
        // Check content length and warn if very large
        const contentWordCount = content.split(/\s+/).length;
        const isVeryLong = content.length > 25000;
        
        if (isVeryLong) {
          loadingMessage.textContent = `Analyzing your content... (Processing ${contentWordCount} words, may take longer)`;
          
          // If it's a very long document, offer more specific options
          if (content.length > 40000) {
            // Halt the current request
            addMessage(`Your document is quite large (${contentWordCount} words), which may exceed the AI's processing limits.`, 'system');
            addMessage(`For better results with long documents, try one of these approaches:`, 'system');
            
            // Create interactive options
            const optionsMsg = document.createElement('div');
            optionsMsg.className = 'message system';
            optionsMsg.innerHTML = `
              <p>Choose a specific improvement focus:</p>
              <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
                <button class="focus-btn" data-focus="grammar" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Check grammar and spelling</button>
                <button class="focus-btn" data-focus="tone" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Improve tone and style</button>
                <button class="focus-btn" data-focus="flow" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Enhance paragraph transitions</button>
                <button class="focus-btn" data-focus="seo" style="background-color: #007bff; color: white; border: none; padding: 8px; border-radius: 4px; text-align: left; cursor: pointer;">Optimize for SEO</button>
              </div>
            `;
            chatMessages.appendChild(optionsMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Add event listeners to the focus buttons
            optionsMsg.querySelectorAll('.focus-btn').forEach(btn => {
              btn.addEventListener('click', function() {
                const focusArea = this.getAttribute('data-focus');
                let newPrompt = '';
                
                switch(focusArea) {
                  case 'grammar':
                    newPrompt = "Please check my blog post for grammar and spelling issues. Flag any errors you find with suggestions.";
                    break;
                  case 'tone':
                    newPrompt = "Please improve the tone and style of my blog post. Make it more engaging and professional.";
                    break;
                  case 'flow':
                    newPrompt = "Please improve the transitions between paragraphs. Make the content flow more smoothly.";
                    break;
                  case 'seo':
                    newPrompt = "Please suggest improvements to optimize my blog post for search engines. Include keyword recommendations.";
                    break;
                }
                
                // Add the selected focus as a user message
                addMessage(newPrompt, 'user');
                
                // Show loading spinner
                loadingSpinner.style.display = 'flex';
                loadingMessage.textContent = 'AI is analyzing...';
                
                // Make request with the focused prompt
                fetch('{% url "blog:ai_blog_improve" %}', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                  },
                  body: JSON.stringify({
                    content: content,
                    title: postTitle.value
                  })
                })
                .then(response => response.json())
                .then(data => {
                  // Hide loading spinner
                  loadingSpinner.style.display = 'none';
                  
                  if (data.error) {
                    // Handle error
                    addMessage(`Error: ${data.error}`, 'system');
                    return;
                  }
                  
                  // Add AI response to chat
                  addMessage(data.suggestions, 'ai');
                  
                  // Update content if provided
                  if (data.improved_content) {
                    // Setup diff view
                    prepareDiffView(content, data.improved_content);
                    
                    // Create message with buttons
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message system';
                    messageDiv.innerHTML = `
                      <p>The AI has suggested improvements based on your request.</p>
                      <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="apply-btn" style="background-color: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Apply All Changes</button>
                        <button class="view-diff-btn" style="background-color: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">View in Diff Tab</button>
                      </div>
                    `;
                    chatMessages.appendChild(messageDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    
                    // Add event listeners
                    messageDiv.querySelector('.apply-btn').addEventListener('click', function() {
                      postContent.value = data.improved_content;
                      updatePreview();
                      versionHistory.addVersion(data.improved_content, 'ai');
                      this.parentNode.innerHTML = '<p> Improvements applied to the editor</p>';
                      this.parentNode.parentNode.style.backgroundColor = '#28a745';
                      this.parentNode.parentNode.style.color = 'white';
                    });
                    
                    messageDiv.querySelector('.view-diff-btn').addEventListener('click', function() {
                      document.querySelector('.editor-tab[data-tab="diff"]').click();
                    });
                  }
                })
                .catch(error => {
                  console.error('Error:', error);
                  loadingSpinner.style.display = 'none';
                  addMessage('An error occurred while analyzing your content. Please try again.', 'system');
                });
              });
            });
            
            // Hide loading spinner
            loadingSpinner.style.display = 'none';
            
            // Don't proceed with the original request
            return;
          }
        }
        
        // Send request to AI
        fetch('{% url "blog:ai_blog_improve" %}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
          },
          body: JSON.stringify({
            content: content,
            title: postTitle.value
          })
        })
        .then(response => response.json())
        .then(data => {
          // Hide loading spinner
          loadingSpinner.style.display = 'none';
          
          if (data.error) {
            // Handle error
            addMessage(`Error: ${data.error}`, 'system');
            return;
          }
          
          // Add AI response to chat
          addMessage(data.suggestions, 'ai');
          
          // Update content if provided
          if (data.improved_content) {
            // Store the original content
            const originalContent = postContent.value;
            
            // Create message in chat
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.innerHTML = `
              <p>The AI has suggested improvements to your content. View changes in the Diff tab.</p>
              <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="apply-btn" style="background-color: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Apply All Changes</button>
                <button class="view-diff-btn" style="background-color: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">View in Diff Tab</button>
              </div>
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Prepare the diff view content
            prepareDiffView(originalContent, data.improved_content);
            
            // Add event listeners to buttons
            messageDiv.querySelector('.apply-btn').addEventListener('click', function() {
              postContent.value = data.improved_content;
              this.parentNode.innerHTML = '<p> Improvements applied to the editor</p>';
              this.parentNode.parentNode.style.backgroundColor = '#28a745';
              this.parentNode.parentNode.style.color = 'white';
              
              // Switch back to editor tab
              document.querySelector('.editor-tab[data-tab="editor"]').click();
              
              // Add the change as a new version
              versionHistory.addVersion(data.improved_content, 'ai');
            });
            
            messageDiv.querySelector('.view-diff-btn').addEventListener('click', function() {
              // Switch to diff tab
              document.querySelector('.editor-tab[data-tab="diff"]').click();
            });
          }
        })
        .catch(error => {
          console.error('Error:', error);
          loadingSpinner.style.display = 'none';
          addMessage('An error occurred while analyzing your content. Please try again.', 'system');
        });
      }
      
      /**
       * Prepares the diff view for comparing original and improved content
       * @param {string} originalContent - The original content
       * @param {string} improvedContent - The improved content
       */
      function prepareDiffView(originalContent, improvedContent) {
        // Get the diff tab container
        const diffTab = document.getElementById('diffTab');
        
        // Store the diff versions in localStorage for restoration
        localStorage.setItem(storageManager.KEYS.DIFF_PREVIOUS, originalContent);
        localStorage.setItem(storageManager.KEYS.DIFF_CURRENT, improvedContent);
        
        // Split content into lines
        const originalLines = originalContent.split("\n");
        const improvedLines = improvedContent.split("\n");
        
        // Create the diff view
        let diffHTML = `
          <div class="inline-diff-container">
            <div class="diff-header">
              <h4>Content Comparison</h4>
              <div class="diff-legend">
                <span class="diff-removed">Removed Content</span>
                <span class="diff-added">Added Content</span>
              </div>
            </div>
            <div class="diff-content">
        `;
        
        // Create diff content with line-by-line comparison
        for (let i = 0; i < Math.max(originalLines.length, improvedLines.length); i++) {
          const originalLine = i < originalLines.length ? originalLines[i] : '';
          const improvedLine = i < improvedLines.length ? improvedLines[i] : '';
          
          if (originalLine !== improvedLine) {
            // Lines are different
            if (originalLine) {
              diffHTML += `<div class="diff-line diff-removed">${originalLine}</div>`;
            }
            if (improvedLine) {
              diffHTML += `<div class="diff-line diff-added">${improvedLine}</div>`;
            }
          } else {
            // Lines are the same
            diffHTML += `<div class="diff-line">${originalLine}</div>`;
          }
        }
        
        diffHTML += `
            </div>
            <div class="diff-actions">
              <button class="apply-changes">Apply All Changes</button>
              <button class="close-diff">Return to Editor</button>
            </div>
          </div>
        `;
        
        // Set the diff content
        diffTab.innerHTML = diffHTML;
        
        // Add event listeners to diff actions
        diffTab.querySelector('.apply-changes').addEventListener('click', function() {
          // Apply the improved content
          postContent.value = improvedContent;
          
          // Switch back to editor tab
          document.querySelector('.editor-tab[data-tab="editor"]').click();
          
          // Add system message
          addMessage(' Improvements have been applied to the editor', 'system');
          
          // Add the change as a new version
          versionHistory.addVersion(improvedContent, 'ai');
        });
        
        diffTab.querySelector('.close-diff').addEventListener('click', function() {
          // Switch back to editor tab
          document.querySelector('.editor-tab[data-tab="editor"]').click();
        });
      }
      
      // Save post
      function savePost() {
        const title = postTitle.value.trim();
        const content = postContent.value.trim();
        const author = postAuthor.value;
        const category = postCategory.value;
        const status = postStatus.value;
        
        if (!title) {
          alert('Please enter a title for your blog post.');
          return;
        }
        
        if (!content) {
          alert('Please enter content for your blog post.');
          return;
        }
        
        if (!author) {
          alert('Please select an author for your blog post.');
          return;
        }
        
        // Set form values
        document.getElementById('formTitle').value = title;
        document.getElementById('formContent').value = content;
        document.getElementById('formAuthor').value = author;
        document.getElementById('formCategory').value = category;
        document.getElementById('formStatus').value = status;
        
        // Submit the form
        document.getElementById('saveForm').submit();
      }
      
      // Event listeners
      sendButton.addEventListener('click', handleUserMessage);
      
      userInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleUserMessage();
        }
      });
      
      /**
       * Event listener for content changes in the editor
       * - Updates the preview with a smart debounce approach:
       *   - 500ms after first change (quick feedback)
       *   - 1500ms for subsequent rapid changes (reduce flickering)
       * - Creates new versions after 3 seconds of inactivity
       * - Persists state to localStorage
       */
      /**
       * Smart Debounce Preview System
       * 
       * This advanced input handling system provides responsive preview updates
       * with intelligent timing based on user typing patterns.
       * 
       * Key features:
       * 1. Adapts preview delay based on typing speed and patterns
       * 2. Quick updates after pauses for immediate feedback
       * 3. Longer delays during rapid typing to prevent flickering
       * 4. Automatic state persistence with each meaningful change
       * 5. Separates preview updates from version history creation
       * 6. Balances responsiveness with performance optimization
       */
      let lastEditTime = 0;
      let lastPreviewTime = 0;
      
      postContent.addEventListener('input', function() {
        const now = Date.now();
        const timeSinceLastEdit = now - lastEditTime;
        const timeSinceLastPreview = now - lastPreviewTime;
        
        // Update last edit time for pattern detection
        lastEditTime = now;
        
        // Cancel pending preview updates to prevent unnecessary processing
        clearTimeout(this.debounce);
        
        // Intelligently determine debounce delay based on typing pattern
        let previewDelay = 1000; // Default moderate delay
        
        // Adaptive timing logic:
        if (timeSinceLastPreview > 2000) {
          // Quick feedback after a pause (first edit or resumed editing)
          // This provides immediate visual feedback when the user starts typing
          previewDelay = 500;
        } 
        else if (timeSinceLastEdit < 300) {
          // Longer delay during rapid typing to prevent constant re-rendering
          // This improves performance when the user is typing continuously
          previewDelay = 1500;
        }
        
        // Schedule the preview update with the adaptive delay
        this.debounce = setTimeout(function() {
          // Record when preview was last updated for future adaptation
          lastPreviewTime = Date.now();
          
          // Update the preview with current content
          updatePreview();
          
          // Persist the current state to localStorage
          storageManager.saveEditorState();
        }, previewDelay);
        
        // Version history creation is handled separately with a longer delay
        // This separates minor edits (character by character) from meaningful changes
        clearTimeout(postContent.versionDebounce);
        postContent.versionDebounce = setTimeout(function() {
          // Create a new version point after 3 seconds of inactivity
          // This represents a meaningful editing pause worth tracking
          versionHistory.addVersion(postContent.value, 'edit');
        }, 3000); // 3-second inactivity threshold for significant changes
      });
      
      // Save state when metadata changes
      [postTitle, postCategory, postAuthor, postStatus].forEach(field => {
        field.addEventListener('change', function() {
          storageManager.saveEditorState();
        });
      });
      
      // Modal event listeners
      historyButton.addEventListener('click', function() {
        // Make sure we have at least one version
        if (versionHistory.versions.length === 0 && postContent.value.trim() !== '') {
          // Create initial version if we have content but no versions
          versionHistory.addVersion(postContent.value, 'init');
        }
        
        // Render the version list
        versionHistory.renderVersionList();
        
        // Show the modal
        historyModal.style.display = 'flex';
      });
      
      closeModal.addEventListener('click', function() {
        historyModal.style.display = 'none';
      });
      
      // Close modal when clicking outside content
      historyModal.addEventListener('click', function(e) {
        if (e.target === historyModal) {
          historyModal.style.display = 'none';
        }
      });
      
      // Undo/Redo buttons
      undoButton.addEventListener('click', function() {
        versionHistory.undo();
      });
      
      redoButton.addEventListener('click', function() {
        versionHistory.redo();
      });
      
      // Handle keyboard shortcuts for undo/redo
      document.addEventListener('keydown', function(e) {
        // Don't capture keystrokes when focused on inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          // But still capture Ctrl+Z and Ctrl+Y in the post content editor
          if (e.target === postContent) {
            if (e.ctrlKey && e.key === 'z') {
              e.preventDefault();
              versionHistory.undo();
            } else if (e.ctrlKey && e.key === 'y') {
              e.preventDefault();
              versionHistory.redo();
            }
          }
          return;
        }
        
        // Global keyboard shortcuts
        if (e.ctrlKey && e.key === 'z') {
          e.preventDefault();
          versionHistory.undo();
        } else if (e.ctrlKey && e.key === 'y') {
          e.preventDefault();
          versionHistory.redo();
        }
      });
      
      previewButton.addEventListener('click', updatePreview);
      suggestImprovements.addEventListener('click', suggestPostImprovements);
      saveButton.addEventListener('click', savePost);
    });
  </script>
  {% endif %}
</div>
{% endblock %}